# INTEGRATED ANALYSIS of three datasets, in homeostasis
# following instructions from:
# https://satijalab.org/seurat/pancreas_integration_label_transfer.html
# but adapting to our datasets

# ~~ Dell Orso data and filtering

obj=c(paste0(prloc,"data/DellOrsoD0/dorso_filtered.rds"),
      paste0(prloc,"data/GiordaniD0/dorso_filtered.rds"),
      paste0(prloc,"data/DeMicheliD0/dorso_filtered.rds"))

if (file.exists(obj[1])){dorso <- readRDS(obj[1])} else {
  dorso1.data <- Read10X(data.dir=paste0(prloc,"data/DellOrsoD0/dorsowt1"))
  dorso2.data <- Read10X(data.dir=paste0(prloc,"data/DellOrsoD0/dorsowt2"))
  
  dorso1 <- CreateSeuratObject(dorso1.data, project="DellOrso", min.cells=3, min.features=200)
  dorso2 <- CreateSeuratObject(dorso2.data, project="DellOrso", min.cells=3, min.features=200)
  rm(dorso1.data,dorso2.data)
  #check dimensions
  #array(c(dim(dorso1),dim(dorso2)), dim=c(2,2))
  dorso <- merge(dorso1, y=dorso2, add.cell.ids=c("wt1","wt2"), project = "DellOrso")
  rm(dorso1,dorso2)
  #dim(dorso[["RNA"]]@counts)
  #caution with mitochondrial reads:
  # low quality/dying cells often exhibit extensive mitochondial contamination
  dorso[["percent.mt"]] <- PercentageFeatureSet(dorso, pattern= "^mt-")
  VlnPlot(dorso, features =c("nFeature_RNA","nCount_RNA","percent.mt"), ncol = 3)  
  ### https://kb.10xgenomics.com/hc/en-us/articles/360001086611-Why-do-I-see-a-high-level-of-mitochondrial-gene-expression-
  
  
  # establishing filters of quality prior to analysis:
  dorso <- subset(dorso, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
  FeatureScatter(dorso, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
  saveRDS(dorso, obj[1])
}
# NOTE: dellOrso METADATA already in object
print("dellOrso METADATA already in object")

# ~~ Giordani data and filtering
if (file.exists(obj[2])){
  gio <- readRDS(obj[2]) 
  } else {
  gio1.data <- read.csv(paste0(prloc,"data/GiordaniD0/GSM3520458_20171018_uninjured_wt_filtered.csv"), 
                        sep=",", header=TRUE, row.names=1)
  gio2.data <- read.csv(paste0(prloc, "data/GiordaniD0/GSM3520459_20180917_uninjured_wt_filtered.csv"),
                        sep=",", header=TRUE, row.names=1)
  
  gio1 <- CreateSeuratObject(gio1.data, project="Giordani", min.cells=3, min.features=200 )
  gio2 <- CreateSeuratObject(gio2.data, project="Giordani", min.cells=3, min.features=200)
  
  array(c(dim(gio1),dim(gio2)), dim=c(2,2))
  
  gio <- merge(gio1, y=gio2, add.cell.ids=c("wt1","wt2"), project = "Giordani")
  dim(gio[["RNA"]]@counts) 
  
  gio[["percent.mt"]] <- PercentageFeatureSet(gio, pattern= "^mt-")
  VlnPlot(gio, features =c("nFeature_RNA","nCount_RNA","percent.mt"), ncol = 3)
  
  gio <- subset(gio, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
  FeatureScatter(gio, feature1= "nCount_RNA", feature2= "nFeature_RNA")
  saveRDS(gio, objGio)
}
# assign "Giordani" to metadata variable 'orig.ident'
gio@meta.data[["orig.ident"]] <- rep("Giordani", length( gio@meta.data[["orig.ident"]] ))

# ~~ De Micheli data and filtering


if (file.exists(obj[3])){
  dmich <- readRDS(obj[3])
}else {
  # Importing zero day file generated by 'extractingDeMich0.R'
  dmi.data <- read.table(paste0(prloc,"data/DeMicheliD0/rawdataD0.txt"), sep="\t",
                         header=T, row.names=1)
  dmich <- CreateSeuratObject(dmi.data, project="DeMicheli", min.cells=3, min.features=200)
  dim(dmich[["RNA"]]@counts) 
  dmich[["percent.mt"]] <- PercentageFeatureSet(dmich, pattern= "^mt-")
  VlnPlot(dmich, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
  dmich <- subset(dmich, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
  FeatureScatter(dmich, feature1="nCount_RNA", feature2 = "nFeature_RNA")
  saveRDS(dmich,obj[3])
}
# assign "DeMicheli" to metadata variable 'orig.ident'
dmich@meta.data[["orig.ident"]] <- rep("DeMicheli", length( dmich@meta.data[["orig.ident"]] ))


# **** INTEGRATION ******

muscle.list <- c(dorso, gio, dmich)
# preprocessing: log-normalisation and variable features
for (i in 1:length(x=muscle.list)) {
  muscle.list[[i]] <- NormalizeData(muscle.list[[i]],verbose=FALSE)
  muscle.list[[i]] <- FindVariableFeatures(muscle.list[[i]], 
                                           selection.method="vst",nfeatures=2500, verbose=FALSE)
}
# by default this function uses 2000 features for anchor finding
muscle.anchors <- FindIntegrationAnchors(object.list = muscle.list, dims=1:30)
muscle.integrated <- IntegrateData(anchorset = muscle.anchors, dims = 1:30)

saveRDS(muscle.integrated, paste0(prloc,"results/2000feat.rds"))

# here clear off unused objects
if (dim(muscle.integrated[["RNA"]]@counts)[2] == dim(muscle.integrated)[2]){
  print("note that dim RNA@counts is equal to dim object")
}else{stop()}
quit()
# reRun first 27 lines !!!!!!!
muscle.integrated <- readRDS(paste0(prloc,"results/2000feat.rds"))
library(cowplot)
# switch to integrated assay. The variable features of this assay are
# automatically set during IntegrateData
DefaultAssay(object = muscle.integrated) <- "integrated"

# Run the standard workflow for visualization and clustering
muscle.integrated <- ScaleData(object = muscle.integrated, verbose = FALSE)
muscle.integrated <- RunPCA(object = muscle.integrated, npcs = 30, verbose = FALSE)

#pdf(paste0(roofi,".2000feat.pdf"))
#DimHeatmap(muscle.integrated, dims=1:30, cells = 500, balanced = TRUE)
#dev.off()

#TODO: deselect if wanted(optional):
muscle.integrated <- JackStraw(muscle.integrated, num.replicate = 100)
muscle.integrated <- ScoreJackStraw(muscle.integrated, dims = 1:20)
JackStrawPlot(muscle.integrated,dims=1:20)

ElbowPlot(muscle.integrated)
#the majority of true signal is captured in the first 13 PCs 
# TODO : define nb of dimensions
nbDIM = 13

#KNN
muscle.integrated <- FindNeighbors(muscle.integrated, dims=1:nbDIM)
muscle.integrated <- FindClusters(muscle.integrated, resolution=0.5)


# Run FIt-SNE
source("E:/TRAVAIL/William/Lyon/DATA/INMG_SingleCell-master/scripts/FIt-SNE/fast_tsne.R", chdir=T)

# > dim(muscle.integrated[["RNA"]]@counts)
# [1] 17347 19143 #  Features X Cells

if (dim(muscle.integrated[["RNA"]]@counts)[2] == dim(muscle.integrated)[2]){
  print("note that dim RNA@counts is equal to dim object")
}else{stop()}

nbCELLS.div100 <- round(dim(muscle.integrated)[2]/100) #nombre de cellules divisé par 100

muscle.integrated <- RunTSNE(object = muscle.integrated,
                             perplexity=nbCELLS.div100, 
                             reduction="pca",
                             dims=1:nbDIM,
                             #tsne.method = "FIt-SNE",
                             nthreads=4,
                             reduction.key="FItSNE_",
                             #fast_tsne_path="~/programsSingleCell/FIt-SNE/bin/fast_tsne",
                             max_iter=1000)

maxlabelcluster <- max(as.integer(levels(muscle.integrated@meta.data[["seurat_clusters"]])))
# check clusters found:
nb.clus <- maxlabelcluster+1  # add 1 because first cluster label is "0"
print(paste("clusters found :",nb.clus)) 


library(ggplot2)
library(hexbin)
library(RColorBrewer)

# define colors for plot1
#    RED:      rgb(0.75, 0.11, 0.05,  alpha=0.5) 
# brown, blue, green in order:
ctrans <- c(rgb(0.81, 0.15, 0.49, alpha = 0.4), 
            rgb(0.15, 0.34, 0.95, alpha=0.4),
            rgb(0.4, 0.77, 0.50, alpha=0.5))

#define colors for plot2

mycolors <- colorRampPalette(brewer.pal(8, "Set2"))(nb.clus)

p1 <- DimPlot(object = muscle.integrated, cols=ctrans, reduction = "tsne", 
              group.by = "orig.ident")
p2 <- DimPlot(object = muscle.integrated, reduction = "tsne", cols=mycolors,
              label = TRUE, repel=TRUE)

# compress	: logical. Should PDF streams be generated with Flate compression? Defaults to TRUE.
plot_grid(p1, p2)

# ** find markers UP and DOWN ==> only.pos=FALSE **
muscle.integrated.markers <- FindAllMarkers(muscle.integrated, only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25) #time consuming

#get up and down regulated markers by cluster
names <-  colnames(muscle.integrated.markers)
df <- data.frame()
for (k in names) df[[k]] <- as.character()

for (i in 1:nb.clus){
  miniframe <- muscle.integrated.markers[muscle.integrated.markers$cluster == i-1, ]
  #split by positiv and negative:
  onlypos <- miniframe[miniframe$avg_logFC > 0, ]
  onlyneg <- miniframe[miniframe$avg_logFC < 0,]
  onlypos <- onlypos %>% arrange(p_val)
  onlyneg <- onlyneg %>% arrange(p_val)
  onlypos <- onlypos %>% arrange(desc(avg_logFC))
  onlyneg <- onlyneg %>% arrange(avg_logFC)
  df <- rbind(df,onlypos[1:8,])
  df <- rbind(df,onlyneg[1:8,])
  
} 

write.table(df, paste0(roofi,"topUPandDOWNmarkers8top",nb.clus), sep="\t", col.names = TRUE, row.names = FALSE)

save(muscle.integrated, muscle.integrated.markers, file=paste0(roofi,".2000feat.fitsne_",nb.clus,"markers.RData"))
# load .RData file if session was closed and re-opened at this point
pdf(paste0(roofi,"2000feat.plotsbyfeat",nb.clus))
FeaturePlot(muscle.integrated, features=c("Smoc2","Pi16", "Sfrp5", "Hic1"))
FeaturePlot(muscle.integrated, features= c("Pax7","Cd34", "Notch2"))  
dev.off()






#doublets
install.packages("remotes")
remotes::install_github("chris-mcginnis-ucsf/DoubletFinder")
library(DoubletFinder)
dorso1.data <- Read10X(data.dir=paste0(prloc,"data/DellOrsoD0/dorsowt1"))
dorso2.data <- Read10X(data.dir=paste0(prloc,"data/DellOrsoD0/dorsowt2"))

dorso1 <- CreateSeuratObject(dorso1.data, project="DellOrso", min.cells=3, min.features=200)
dorso2 <- CreateSeuratObject(dorso2.data, project="DellOrso", min.cells=3, min.features=200)
rm(dorso1.data,dorso2.data)
#check dimensions
#array(c(dim(dorso1),dim(dorso2)), dim=c(2,2))
#seurat_obj=list(dorso,dmich,gio)
seurat_obj=list(dorso1,dorso2)
for (i in 1:length(seurat_obj)) {
  seurat_obj[[i]] <- NormalizeData(seurat_obj[[i]])
  seurat_obj[[i]] <- FindVariableFeatures(seurat_obj[[i]], selection.method = "vst", nfeatures = 2000)
  seurat_obj[[i]] <- ScaleData(seurat_obj[[i]])
  seurat_obj[[i]] <- RunPCA(seurat_obj[[i]])
  seurat_obj[[i]] <- RunUMAP(seurat_obj[[i]],dims = 1:10)
  ## pK Identification (no ground-truth) ---------------------------------------------------------------------------------------
  sweep.res.list_muscle <- paramSweep_v3(seurat_obj[[i]], PCs = 1:10, sct = FALSE)
  sweep.stats_muscle <- summarizeSweep(sweep.res.list_muscle, GT = FALSE)
  bcmvn_muscle <- find.pK(sweep.stats_muscle)
  ## pK Identification (ground-truth) ------------------------------------------------------------------------------------------
  sweep.res.list_muscle <- paramSweep_v3(seurat_obj[[i]], PCs = 1:10, sct = FALSE)
  gt.calls <- seurat_obj[[i]]@meta.data[rownames(sweep.res.list_muscle[[1]]), "GT"]   ## GT is a vector containing "Singlet" and "Doublet" calls recorded using sample multiplexing classification and/or in silico geneotyping results 
  sweep.stats_muscle <- summarizeSweep(sweep.res.list_muscle, GT = TRUE, GT.calls = gt.calls)
  bcmvn_muscle <- find.pK(sweep.stats_muscle)
  
  ## Homotypic Doublet Proportion Estimate -------------------------------------------------------------------------------------
  annotations <- seurat_obj[[i]]@meta.data$CellType.sum1
  homotypic.prop <- modelHomotypic(annotations)           ## ex: annotations <- seu_muscle@meta.data$ClusteringResults
  nExp_poi <- round(0.075*length(seurat_obj[[i]]@cell.names))  ## Assuming 7.5% doublet formation rate - tailor for your dataset
  nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))
  
  ## Run DoubletFinder with varying classification stringencies ----------------------------------------------------------------
  seurat_obj[[i]]  <- doubletFinder_v3(seurat_obj[[i]] , PCs = 1:10, pN = 0.25, pK = 0.09, nExp = nExp_poi, reuse.pANN = FALSE, sct = FALSE)
  seurat_obj[[i]]  <- doubletFinder_v3(seurat_obj[[i]] , PCs = 1:10, pN = 0.25, pK = 0.09, nExp = nExp_poi.adj, reuse.pANN = "pANN_0.25_0.09_913", sct = FALSE)
  DimPlot(seurat_obj[[i]],pt.size = 1,label=TRUE, label.size = 5,reduction = "umap",group.by = "cluster")+theme(aspect.ratio = 1)
}
devtools::install_github('EDePasquale/DoubletDecon')
newFiles=Improved_Seurat_Pre_Process(dorso, num_genes=100, write_files=FALSE)



# to give appropriate names to cells , use the table having suffix "UPandDOWNmarkers"
# and do as in "assigningto_clusters.R" located in CompareMarkers folder

new.cluster.ids <- c("B_lymphocytes.CD4" , "FAPS, Smoc2+"  ,  "Endothelial cells" ,        
                     "Endothelial cells"  , "T_lymphocytes.CD3" , "MuSc" ,                   
                     "Activated Myofibroblasts" , "Tenocytes" , "Endothelial from lymph nodes",
                     "Smooth muscle cells" ,"Myonuclei" , "Neutrophyls_macrophages" ,    
                     "Neutrophyls, macrophages" , "Schwann cells" , "Early T cells" ,              
                     "B_lymphocytes.CD4")  

names(new.cluster.ids) <- levels(muscle.integrated)
muscle.integrated <- RenameIdents(muscle.integrated, new.cluster.ids)

p2noms <- DimPlot(object = muscle.integrated, reduction = "tsne", cols=mycolors,
                  label = TRUE, repel=TRUE)

pdf(paste0(roofi,"2000feat.NOMlabels",nb.clus), width=16, height = 8, compress=TRUE)
plot_grid(p1, p2noms)
dev.off()

topn <- muscle.integrated.markers %>% group_by(cluster) %>% top_n(n = 4, wt = avg_logFC)
pdf(paste0(roofi,"NOMS.Heatmap",nb.clus), width=30, height=15)
DoHeatmap(muscle.integrated, features = topn$gene, group.bar=TRUE, group.colors = mycolors)
dev.off()

# END
